from raspserver import app, socketio
from flask_socketio import send, emit
from flask import jsonify, request, make_response, send_from_directory
import datetime
import calendar
import pytz
import logging
import os

# Temperature list
global_dict = {
    'temperature': []
}

# Temperature unique (web socket cases)
temperature_dict = {
    'value': None,
    'scale': None,
    'timestamp': None
}


@app.route('/')
def index():

    """
    Main resource for sensor server API.

    Method: GET
    Success: Returns FireSensor PWA.
    """

    return app.send_static_file('index.html')


@app.route('/js/<path:filename>')
def load_js_files(filename):

    """
    Get JS static files.

    Method: GET
    Success: Returns JS static file.
    :arg filename
    """

    return send_from_directory(os.path.join('.', 'static', 'js'), filename)


@app.route('/<path:filename>')
def load_service_worker(filename):

    """
    Get JS service-worker static file.

    Method: GET
    Success: Returns JS service-worker static file.
    :arg filename
    """

    return send_from_directory(os.path.join('.', 'static'), filename)


@app.route('/css/<path:filename>')
def load_css_files(filename):

    """
    Get CSS static files.

    Method: GET
    Success: Returns CSS static file.
    :arg filename
    """

    return send_from_directory(os.path.join('.', 'static', 'css'), filename)


@app.route('/read')
def read():

    """
    Get sensor temperature value from dictionary list.

    Method: GET
    Success: Returns JSON response with 200 status

    If there isn't any temperature in list, return an empty object.
    Otherwise, return an object temperature with value and scale.

    Response Model: temperature: {'value': 25, 'scale': 'degrees'},
                    timestamp: 1510667612.0
    """

    # Check if temperature list is empty
    if not global_dict['temperature']:
        temp = {}
    # Get first element from temperature list, and then pop it from list
    else:
        temp = [t for t in global_dict['temperature']][0]
        global_dict['temperature'].pop(0)
    
    data = {
        'timestamp': now(),
        'temperature': temp
    }
    resp = jsonify(data)
    resp.status_code = 200
    return resp


@app.route('/load', methods=['POST'])
def load():

    """
    Store sensor temperature value in dictionary list.

    Method: POST
    Success: Returns JSON response with 200 status
    Error: Returns JSON response with 400 status and message

    If temperature is empty, scale or temperature aren't declared,
    return an error to request.
    Otherwise, return a success request with sent temperature.

    Request Model: {'value': 25, 'scale': 'degrees'}
    """

    # Receive temperature value from server
    temp = request.get_json()
    # Check for object existence and params inside
    if not temp:
        data = jsonify({'error': 'No temperature object sent!'})
        resp = make_response(data, 400)
        return resp
    elif 'value' not in temp:
        data = jsonify({'error': 'Insert temperature value!'})
        resp = make_response(data, 400)
        return resp
    elif 'scale' not in temp:
        data = jsonify({'error': 'Insert temperature scale!'})
        resp = make_response(data, 400)
        return resp

    # Append temperature in list (only use this in queue mode)
    # global_dict['temperature'].append(temp)

    # Save the temperature in a log file
    save_log("Received temperature: " + str(temp['value']) + " in " + temp['scale'] + ".")

    # Append temperature to temperature dict
    temperature_dict['value'] = temp['value']
    temperature_dict['scale'] = temp['scale']
    temperature_dict['timestamp'] = now()

    save_log("Stored temperature: " + str(temperature_dict['value']) + " at " + str(temperature_dict['timestamp']))

    # Dispatch temperature to web socket
    send_temperature()

    # Return success to client with temperature
    resp = jsonify(temperature_dict)
    resp.status_code = 200
    return resp


def send_temperature():

    """
    Send temperature to clients.

    When called, emits a 'temperature_sync' event to WS protocol,
    passing temperature dictionary and a callback to be acknowledged
    by any client. Log a message to check WS connection.
    """

    save_log('Sending temperature to clients...')
    socketio.emit('temperature_sync', temperature_dict, callback=ack)


def ack():

    """
    Acknowledgement callback message (from WS).
    """

    print 'Message was received in client!'


def now():

    """
    Convert current datetime with time zone to timestamp.
    """

    dt = datetime.datetime.now()  # Get current datetime
    mytz = pytz.timezone('America/Sao_Paulo')  # Setting Sao Paulo Timezone
    dt = mytz.normalize(mytz.localize(dt, is_dst=True))  # Converting to datetime
    return calendar.timegm(dt.utctimetuple())  # Return converted timestamp from datetime


def save_log(message):

    """
    Save log in directory file for auditing.
    Checks for Heroku Cloud, which writes logs through stdout.
    :arg message
    """

    # Setting Log Format
    log_format = "%(levelname)s %(asctime)s - %(message)s"

    if os.environ.get('HEROKU') is None:

        # Creating and configuring logger for file handler
        logging.basicConfig(filename="logs/load.log",
                            level=logging.DEBUG,
                            format=log_format)
        app.logger.addHandler(logging.getLogger())

    else:

        # Creating and configuring logger for stream handler
        stream_handler = logging.StreamHandler()
        stream_handler.setFormatter(log_format)
        app.logger.addHandler(stream_handler)
        app.logger.setLevel(logging.DEBUG)

    app.logger.info(message)
